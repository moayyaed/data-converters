{
    "name": "ChirpStack Downlink data converter for Yobiiq EM2101",
    "type": "DOWNLINK",
    "debugMode": true,
    "configuration": {
      "scriptLang": "TBEL",
      "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
      "tbelDecoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions 'decodeToString' and 'decodeToJson' are already built-in **/\n\nreturn result;",
      "encoder": null,
      "tbelEncoder": "// Process data from incoming message and metadata\r\nvar input = {\r\n    fPort : parseInt(metadata.rc_fPort), // from rule chain\r\n    confirmed : metadata.rc_confirmed === \"true\" ? true : false, // from rule chain\r\n    data : msg,\r\n    variables: null,\r\n    devEui : metadata.cs_devEui, // from client scope\r\n    applicationId: metadata.cs_applicationId, // from client scope\r\n};\r\n\r\n// Result object with encoded downlink payload\r\nvar result = {\r\n\r\n    // downlink data content type: JSON, TEXT or BINARY (base64 format)\r\n    contentType: \"TEXT\",\r\n\r\n    // downlink data\r\n    data: bytesToBase64(encodeDownlink(input).bytes),\r\n\r\n    // Optional metadata object presented in key/value format\r\n    metadata: {\r\n        eui: input.devEui,\r\n        DevEUI: input.devEui,\r\n        fPort: input.fPort,\r\n    }\r\n\r\n};\r\n\r\n\r\nreturn result;\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Encode encodes the given object into an array of bytes. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - obj is an object, e.g. {\"temperature\": 22.5}\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\r\nfunction Encode(fPort, obj, variables) {\r\n    // Constants for downlink type\r\n    var CONFIG_DOWNLINK = {\r\n        TYPE    : \"Type\",\r\n        CONFIG  : \"Config\",\r\n        DYNAMIC : \"Dynamic\",\r\n        RELAY   : \"Relay\",\r\n        MEASURE : \"Measure\",\r\n        REQUEST : \"RequestSettings\"\r\n    };\r\n\r\n    if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.CONFIG)\r\n    {\r\n        return encodeDeviceConfiguration(obj[CONFIG_DOWNLINK.CONFIG]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.DYNAMIC)\r\n    {\r\n        return encodeDynamicLimitControl(obj[CONFIG_DOWNLINK.DYNAMIC]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.RELAY)\r\n    {\r\n        return encodeRelayControl(obj[CONFIG_DOWNLINK.RELAY]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.MEASURE)\r\n    {\r\n        return encodePeriodicPackage(obj[CONFIG_DOWNLINK.MEASURE]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.REQUEST)\r\n    {\r\n        return encodeRequestSettings(obj[CONFIG_DOWNLINK.REQUEST]);\r\n    }\r\n\r\n    return [];\r\n}\r\n\r\n// Encode downlink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - data = Object representing the payload that must be encoded.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - bytes = Byte array containing the downlink payload.\r\nfunction encodeDownlink(input) {\r\n    return {\r\n        bytes: Encode(null, input.data, input.variables)\r\n    };\r\n}\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n\r\nfunction encodeDeviceConfiguration(configObj)\r\n{\r\n    // Constants for device configuration \r\n    var CONFIG_DEVICE = {\r\n        FPORT : 50,\r\n        CHANNEL : 0xFF,\r\n        TYPES : {\r\n            \"restart\" : {TYPE : 0x0B, SIZE : 1, MIN : 1, MAX : 1,},\r\n            \"digitalInput\" : {TYPE : 0x47, SIZE : 1, MIN : 0, MAX : 1, CHANNEL : 0x08,},\r\n            \"currentLimitFallback\" : {TYPE : 0x32, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"voltageLimitFallback\" : {TYPE : 0x33, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"powerLimitFallback\" : {TYPE : 0x34, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"deactivationDelayFallback\" : {TYPE : 0x35, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"activationDelayFallback\" : {TYPE : 0x36, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"offsetCurrentFallback\" : {TYPE : 0x37, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"offsetDelayFallback\" : {TYPE : 0x38, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"resetTimeFallback\" : {TYPE : 0x39, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"resetAmountFallback\" : {TYPE : 0x3A, SIZE : 1, MIN : 0, MAX : 255,}\r\n        }\r\n    };\r\n    var encoded = [];\r\n    var param = configObj.Param;\r\n    var value = configObj.Value;\r\n    if(param == null || value == null){\r\n        return [];\r\n    }\r\n\r\n    var config = CONFIG_DEVICE.TYPES[param];\r\n    if(config == null) {\r\n        return [];\r\n    }\r\n    \r\n    if(value < config.MIN || value > config.MAX) {\r\n        return [];\r\n    }\r\n\r\n    if(config.CHANNEL != null)\r\n    {\r\n        encoded.push(config.CHANNEL);\r\n    }else\r\n    {\r\n        encoded.push(CONFIG_DEVICE.CHANNEL);\r\n    }\r\n    encoded.push(config.TYPE);\r\n    for(var i=1; i<=config.SIZE; i=i+1)\r\n    {\r\n        encoded.push( (value >> 8*(config.SIZE - i)) % 256 );\r\n    }\r\n\r\n    return encoded;\r\n}\r\n\r\n\r\nfunction encodeDynamicLimitControl(configObj)\r\n{\r\n    // Constants for Dynamic limit control\r\n    var CONFIG_DYNAMIC = {\r\n        FPORT : 50,\r\n        CHANNEL : 0x01,\r\n        TYPES : {\r\n            \"currentLimit\" : {TYPE : 0x32, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"voltageLimit\" : {TYPE : 0x33, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"powerLimit\" : {TYPE : 0x34, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"deactivationDelay\" : {TYPE : 0x35, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"activationDelay\" : {TYPE : 0x36, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"offsetCurrent\" : {TYPE : 0x37, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"offsetDelay\" : {TYPE : 0x38, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"resetTime\" : {TYPE : 0x39, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"resetAmount\" : {TYPE : 0x3A, SIZE : 1, MIN : 0, MAX : 255,}\r\n        }\r\n    };\r\n    var encoded = [];\r\n    var param = configObj.Param;\r\n    var value = configObj.Value;\r\n    if(param == null || value == null){\r\n        return [];\r\n    }\r\n\r\n    var config = CONFIG_DYNAMIC.TYPES[param];\r\n    if(config == null) {\r\n        return [];\r\n    }\r\n    \r\n    if(value < config.MIN || value > config.MAX) {\r\n        return [];\r\n    }\r\n\r\n    encoded.push(CONFIG_DYNAMIC.CHANNEL);\r\n    encoded.push(config.TYPE);\r\n    for(var i=1; i<=config.SIZE; i=i+1)\r\n    {\r\n        encoded.push( (value >> 8*(config.SIZE - i)) % 256 );\r\n    }\r\n    \r\n    return encoded;\r\n}\r\n\r\n\r\nfunction encodeRelayControl(configObj)\r\n{\r\n    // Constants for Relay control\r\n    var CONFIG_RELAY = {\r\n        FPORT : 50,\r\n        CHANNEL : 0x07,\r\n        TYPES : {\r\n            \"reset\" : {TYPE : 0x46, SIZE : 1, MIN : 1, MAX : 1,},\r\n            \"controlMode\" : {TYPE : 0x47, SIZE : 1, MIN : 0, MAX : 1,},\r\n            \"relayCommand\" : {TYPE : 0x48, SIZE : 1, MIN : 0, MAX : 1,}\r\n        }\r\n    };\r\n    var encoded = [];\r\n    var param = configObj.Param;\r\n    var value = configObj.Value;\r\n    if(param == null || value == null){\r\n        return [];\r\n    }\r\n\r\n    var config = CONFIG_RELAY.TYPES[param];\r\n    if(config == null) {\r\n        return [];\r\n    }\r\n    \r\n    if(value < config.MIN || value > config.MAX) {\r\n        return [];\r\n    }\r\n\r\n    encoded.push(CONFIG_RELAY.CHANNEL);\r\n    encoded.push(config.TYPE);\r\n    for(var i=1; i<=config.SIZE; i=i+1)\r\n    {\r\n        encoded.push( (value >> 8*(config.SIZE - i)) % 256 );\r\n    }\r\n    \r\n    return encoded;\r\n}\r\n\r\n\r\n\r\nfunction encodePeriodicPackage(configObj)\r\n{\r\n    // Constants for device periodic package \r\n    var CONFIG_PERIODIC = {\r\n        CHANNEL : 0xFF,\r\n        TYPES : {\r\n            \"Interval\" : {TYPE : 0x14, SIZE : 1, MIN : 1, MAX : 255,},\r\n            \"Mode\" : {TYPE : 0x15, SIZE : 1, MIN : 0, MAX : 1,},\r\n            \"Status\" : {TYPE : 0x16, SIZE : 1, MIN : 0, MAX : 1,},\r\n            \"Measurement\" : {TYPE : 0x17, SIZE : 1, MIN : 0, MAX : 10,},\r\n        },\r\n        MEASUREMENTS : {\r\n            index : 0x00,\r\n            timestamp : 0x01,\r\n            dataloggerTimestamp : 0x03,\r\n            activeEnergyImportL1T1 : 0x04,\r\n            activeEnergyImportL1T2 : 0x05,\r\n            activeEnergyExportL1T1 : 0x06,\r\n            activeEnergyExportL1T2 : 0x07,\r\n            reactiveEnergyImportL1T1 : 0x08,\r\n            reactiveEnergyImportL1T2 : 0x09,\r\n            reactiveEnergyExportL1T1 : 0x0A,\r\n            reactiveEnergyExportL1T2 : 0x0B,\r\n            voltageL1N : 0x0C,\r\n            currentL1 : 0x10,\r\n            activePowerL1 : 0x14,\r\n            reactivePowerL1 : 0x17,\r\n            apparentPowerL1 : 0x1A,\r\n            powerFactorL1 : 0x1d,\r\n            phaseAngleL1 : 0x20,\r\n            frequency : 0x23,\r\n            totalSystemActivePower : 0x24,\r\n            totalSystemReactivePower : 0x25,\r\n            totalSystemApparentPower : 0x26,\r\n            maximumL1CurrentDemand : 0x27,\r\n            AveragePower : 0x2A,\r\n            midYearOfCertification : 0x2B,\r\n            manufacturedYear : 0xF0,\r\n            firmwareVersion : 0xF1,\r\n            hardwareVersion : 0xF2,\r\n        }\r\n    };\r\n    var encoded = [];\r\n    var config = {};\r\n    var value = -1;\r\n    if(configObj.Interval == null || configObj.Mode == null ||\r\n        configObj.Status == null || configObj.Measurement == null){\r\n        return [];\r\n    }\r\n    \r\n    // Encode Interval, Mode, Status\r\n    var fields = [\"Interval\", \"Mode\", \"Status\"];\r\n    foreach(field: fields)\r\n    {\r\n        config = CONFIG_PERIODIC.TYPES[field];\r\n        value = configObj[field];\r\n        if(value < config.MIN || value > config.MAX){\r\n            return [];\r\n        }\r\n        encoded.push(CONFIG_PERIODIC.CHANNEL);\r\n        encoded.push(config.TYPE);\r\n        encoded.push(value);\r\n    }\r\n    // Encode Measurement\r\n    config = CONFIG_PERIODIC.TYPES.Measurement;\r\n    if(configObj.Measurement.size < config.MIN || \r\n        configObj.Measurement.size > config.MAX){\r\n        return [];\r\n    }\r\n    encoded.push(CONFIG_PERIODIC.CHANNEL);\r\n    encoded.push(config.TYPE);\r\n    foreach(field : configObj.Measurement)\r\n    {\r\n        if(CONFIG_PERIODIC.MEASUREMENTS[field] == null){\r\n            return [];\r\n        }\r\n        encoded.push(CONFIG_PERIODIC.MEASUREMENTS[field]);\r\n    }\r\n\r\n    return encoded;\r\n}\r\n\r\n\r\nfunction encodeRequestSettings(configObj)\r\n{\r\n    // Constants for request settings\r\n    var CONFIG_REQUEST = {\r\n        FPORT: 50,\r\n        CHANNEL : 0x02,\r\n        TYPE : 0x0B,\r\n        MIN : 1,\r\n        MAX : 10,\r\n        SETTINGS : {\r\n            currentLimitFallback : 0x3C,\r\n            voltageLimitFallback : 0x3D,\r\n            powerLimitFallback : 0x3E,\r\n            deactivationDelayFallback : 0x3F,\r\n            activationDelayFallback : 0x40,\r\n            offsetCurrentFallback : 0x41,\r\n            offsetDelayFallback : 0x42,\r\n            resetTimeFallback : 0x43,\r\n            resetAmountFallback : 0x44,\r\n            currentLimitDynamic : 0x50,\r\n            voltageLimitDynamic : 0x51,\r\n            powerLimitDynamic : 0x52,\r\n            deactivationDelayDynamic : 0x53,\r\n            activationDelayDynamic : 0x54,\r\n            offsetCurrentDynamic : 0x55,\r\n            offsetDelayDynamic : 0x56,\r\n            resetTimeDynamic : 0x57,\r\n            resetAmountDynamic : 0x58,\r\n        }\r\n    };\r\n    var encoded = [];\r\n    \r\n    if(configObj.size < CONFIG_REQUEST.MIN ||\r\n        configObj.size > CONFIG_REQUEST.MAX){\r\n        return [];\r\n    }\r\n\r\n    foreach(field: configObj)\r\n    {\r\n        encoded.push(CONFIG_REQUEST.CHANNEL);\r\n        encoded.push(CONFIG_REQUEST.TYPE);\r\n        if(CONFIG_REQUEST.SETTINGS[field] == null)\r\n        {\r\n            return [];\r\n        }\r\n        encoded.push(CONFIG_REQUEST.SETTINGS[field]);\r\n    }\r\n\r\n    return encoded;\r\n}",
      "updateOnlyKeys": [
        "manufacturer"
      ]
    },
    "additionalInfo": {
      "description": ""
    },
    "edgeTemplate": false
  }