{
  "name": "ChirpStack Uplink data converter for Yobiiq RM200",
  "type": "UPLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "var data = decodeToJson(payload);\r\nvar deviceName = data.deviceInfo.deviceName;\r\nvar deviceType = 'Digital Controller';\r\nvar groupName = 'Digital Controllers';\r\nvar customerName = data.deviceInfo.tags.customerName;\r\n\r\nvar RELAY = {\r\n    OFF_NAME: \"OFF\",\r\n    ON_NAME: \"ON\",\r\n    RETAIN_NAME: \"RETAIN\",\r\n    CHANNEL_1_STATE_NAME: \"channel1State\",\r\n    CHANNEL_2_STATE_NAME: \"channel2State\",\r\n};\r\n\r\nvar CHANNEL_STATES = {\r\n    \"0x00\" : {state:RELAY.OFF_NAME, reason:\"AUTO\"},\r\n    \"0x01\" : {state:RELAY.ON_NAME,  reason:\"AUTO\"},\r\n    \"0x02\" : {state:RELAY.OFF_NAME, reason:\"MANUAL\"},\r\n    \"0x03\" : {state:RELAY.ON_NAME,  reason:\"MANUAL\"},\r\n};\r\n\r\n// --- attributes and telemetry objects ---\r\nvar telemetryArray = [];\r\nvar attributes = {};\r\n\r\n// --- Timestamp parsing\r\nvar dateString = data.time;\r\nvar timestamp = -1;\r\nif (dateString != null) {\r\n  timestamp = new Date(dateString).getTime();\r\n  if (timestamp == -1) {\r\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\r\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\r\n      if (millisecondsEndIndex == -1) {\r\n          millisecondsEndIndex = dateString.lastIndexOf('Z');\r\n      }\r\n      if (millisecondsEndIndex == -1) {\r\n          millisecondsEndIndex = dateString.lastIndexOf('-');\r\n      }\r\n      if (millisecondsEndIndex == -1) {\r\n          if (dateString.length >= secondsSeparatorIndex + 3) {\r\n              dateString = dateString.substring(0, secondsSeparatorIndex + 3);\r\n          }\r\n      } else {\r\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\r\n              dateString.substring(millisecondsEndIndex, dateString.length);\r\n      }\r\n      timestamp = new Date(dateString).getTime();\r\n  }\r\n}\r\n// If we cannot parse timestamp - we will use the current timestamp\r\nif (timestamp == -1) {\r\n    timestamp = Date.now();\r\n}\r\n\r\nattributes.putAll( getVersionControl() );\r\nattributes.putAll(data.deviceInfo);\r\nattributes.remove('deviceName');\r\n\r\nif(data.fPort == null)\r\n{\r\n    // No uplink : end of decoder\r\n    var result = {\r\n        deviceName: deviceName,\r\n        deviceType: deviceType,\r\n        groupName: groupName,\r\n        attributes: attributes,\r\n        telemetry: telemetryArray\r\n    };\r\n    if(customerName != null){\r\n        result.customerName = customerName;\r\n    }    \r\n    return result;\r\n}\r\n\r\nvar telemetryData = {};\r\ntelemetryData.fPort = data.fPort;\r\ntelemetryData.confirmed = data.confirmed;\r\ntelemetryData.fCnt = data.fCnt;\r\ntelemetryData.dr = data.dr;\r\ntelemetryArray.push({ts:timestamp, values:telemetryData});\r\n\r\n// input uplink\r\nvar input = {\r\n    fPort: data.fPort,\r\n    bytes: hexStringToIntList(base64ToHex(data.data)),\r\n    variables: null,\r\n};\r\n\r\n// Decode uplink\r\nvar up = {\r\n    timestamp : timestamp,\r\n    fPort: input.fPort,\r\n    object: decodeUplink(input).data,\r\n    isDownlinkAnswer: false,\r\n    isBasicInfo: false,\r\n    isParameter: false,\r\n    isAlarm: false\r\n};\r\n\r\nif(up.fPort == 50 || up.fPort == 100)\r\n{\r\n    if(up.object.warning != null || up.object.info != null)\r\n    {\r\n        up.isDownlinkAnswer = true;\r\n    }\r\n    /* hardwareVersion indicates that is basic info so save them to attributes */\r\n    else if(up.object.hardwareVersion != null || up.fPort == 50)\r\n    {\r\n        up.isBasicInfo = true;\r\n    }\r\n    else if(up.fPort == 100)\r\n    {\r\n        up.isParameter = true;\r\n    }\r\n} else if(up.fPort >= 1 && up.fPort <= 5)\r\n{\r\n    if(up.object.warning != null || up.object.info != null)\r\n    {\r\n        up.isDownlinkAnswer = true;\r\n    }\r\n}else if (up.fPort == 11)\r\n{\r\n    up.isAlarm = true;\r\n}\r\n\r\nvar decodedAttributes = getAttributes(up);\r\ndecodedAttributes.remove(\"manufacturer\");\r\nattributes.putAll( decodedAttributes );\r\nvar telemetry = getTelemetry(up);\r\nif(telemetry != null){\r\n    telemetryArray.push(telemetry);\r\n}\r\n\r\nvar result = {\r\n    deviceName: deviceName,\r\n    deviceType: deviceType,\r\n    // assetName: assetName,\r\n    // assetType: assetType,\r\n    groupName: groupName,\r\n    attributes: attributes,\r\n    telemetry: telemetryArray\r\n};\r\nif(customerName != null)\r\n{\r\n    result.customerName = customerName;\r\n}\r\n\r\nreturn result;\r\n\r\n\r\n\r\n/**\r\n * @brief converts device parameters into attributes\r\n * \r\n * @param up uplink object \r\n * \r\n * @return device attributes\r\n */\r\nfunction getAttributes(up)\r\n{\r\n\tvar params = {};\r\n    params.latestFPort = up.fPort;\r\n\r\n\tif(up.isDownlinkAnswer == false && up.isBasicInfo == false &&  up.isParameter == false)\r\n\t{\r\n\t\treturn params;\r\n\t}\r\n\r\n\tif(up.object.warning != null )\r\n\t{\r\n\t\tparams.latestDownlinkStatus = up.timestamp + \"-FAILURE\";\r\n\t\treturn params;\r\n\t}\r\n\r\n\tif(up.object.info != null)\r\n\t{\r\n\t\tparams.latestDownlinkStatus = up.timestamp + \"-SUCCESS\";\r\n\t\treturn params;\r\n\t}\r\n    \r\n    var additionalAttributes = {};\r\n    foreach(element: up.object.entrySet())\r\n    {\r\n        if(up.isBasicInfo){\r\n            additionalAttributes[element.key] = element.value;\r\n        }else if(up.isParameter){\r\n            var capitalizeKey = element.key.substring(0, 1).toUpperCase() + element.key.substring(1);\r\n            additionalAttributes[\"latestParameter\" + capitalizeKey] = element.value;\r\n        }\r\n    }\r\n\r\n    if(up.isBasicInfo)\r\n    {\r\n        params.putAll(additionalAttributes);\r\n    }else if(up.isParameter){\r\n        params.latestDownlinkStatus = up.timestamp + \"-SUCCESS\";\r\n        params.latestIncomingParameters = additionalAttributes;\r\n    }\r\n\r\n\treturn params;\r\n}\r\n\r\n/**\r\n * @brief converts device measurements into telemetry\r\n * \r\n * @param up uplink object \r\n * \r\n * @return device telemetry\r\n */\r\nfunction getTelemetry(up)\r\n{\r\n\tif(up.isBasicInfo || up.isDownlinkAnswer || up.isParameter)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\r\n    var ts = up.timestamp;\r\n    if(up.isAlarm)\r\n    {\r\n        ts = up.object.timestamp * 1000;\r\n        up.object.remove(\"timestamp\");\r\n\r\n    }\r\n    if(up.object.dataloggerTimestamp != null)\r\n    {\r\n        // use dataloggerTimestamp when it exists\r\n        ts = up.object.dataloggerTimestamp * 1000;   // dataloggerTimestamp is in seconds\r\n        up.object.remove(\"dataloggerTimestamp\");\r\n    }\r\n\r\n    var values = {};\r\n    foreach(element: up.object.entrySet())\r\n    {\r\n        values[element.key] = element.value;\r\n    }\r\n    \r\n    return {ts: ts, values: values};\r\n}\r\n\r\n\r\n/********************************** Yobiiq Decoder ******************************/\r\n\r\nfunction decodeBasicInformation(bytes)\r\n{\r\n    // Configuration constants for device basic info\r\n    var CONFIG_INFO = {\r\n        FPORT    : 50,\r\n        CHANNEL  : 0xFF,\r\n        TYPES    : {\r\n            \"0x05\" : {SIZE : 2, NAME : \"hardwareVersion\", DIGIT: false},\r\n            \"0x04\" : {SIZE : 2, NAME : \"firmwareVersion\", DIGIT: false},\r\n            \"0x03\" : {SIZE : 4, NAME : \"deviceSerialNumber\"},\r\n            \"0x01\" : {SIZE : 0, NAME : \"manufacturer\"}, // size to be determinated\r\n            \"0x02\" : {SIZE : 0, NAME : \"deviceModel\"},  // size to be determinated\r\n            \"0x07\" : {SIZE : 1, NAME : \"batteryPercentage\"},\r\n            \"0x08\" : {SIZE : 1, NAME : \"batteryVoltage\", RESOLUTION: 0.1},\r\n            \"0x11\" : {SIZE : 1, NAME : \"deviceClass\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Class A\",\r\n                    \"0x01\" : \"Class B\",\r\n                    \"0x02\" : \"Class C\",\r\n                },\r\n            },\r\n            \"0x06\" : {SIZE : 1, NAME : \"powerEvent\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"AC Power Off\",\r\n                    \"0x01\" : \"AC Power On\",\r\n                },\r\n            }\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_INFO.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_INFO.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    \r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // No channel checking\r\n        // Type of basic information\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        var info = CONFIG_INFO.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded[CONFIG_INFO.ERROR_NAME] = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        // Decoding\r\n        var value = 0;\r\n        if(size != 0)\r\n        {\r\n            if(info.DIGIT != null)\r\n            {\r\n                if(info.DIGIT == false)\r\n                {\r\n                    // Decode into \"V\" + DIGIT STRING + \".\" DIGIT STRING format\r\n                    value = getDigitStringArrayNoFormat(bytes, index, size);\r\n                    value = \"V\" + value[0] + \".\" + value[1];\r\n                }else\r\n                {\r\n                    // Decode into DIGIT STRING format\r\n                    value = getDigitStringArrayEvenFormat(bytes, index, size);\r\n                    value = value.toString();\r\n                }\r\n            }\r\n            else if(info.VALUES != null)\r\n            {\r\n                // Decode into STRING (VALUES specified in CONFIG_INFO)\r\n                value = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n                value = info.VALUES[value];\r\n            }else\r\n            {\r\n                // Decode into DECIMAL format\r\n                value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n            }\r\n            if(info.RESOLUTION != null)\r\n            {\r\n                value = value * info.RESOLUTION;\r\n                value = toFixed(value, 2);\r\n            }\r\n            decoded[info.NAME] = value;\r\n            index = index + size;\r\n        }else\r\n        {\r\n            // Device Model\r\n            size = getSizeBasedOnChannel(bytes, index, channel);\r\n            decoded[info.NAME] = getStringFromBytesBigEndianFormat(bytes, index, size);\r\n            index = index + size;\r\n        }\r\n    }\r\n    return decoded;\r\n}\r\n\r\nfunction decodeDeviceData(bytes)\r\n{\r\n    // Configuration constants for device periodic data\r\n    var CONFIG_PERIODIC = {\r\n        CHANNEL  : 0xDD,\r\n        FPORT_MIN : 1,\r\n        FPORT_MAX : 5,\r\n        TYPES : {\r\n            \"0xFE\" : {SIZE: 4, TYPE: \"U32\", NAME : \"timestamp\"},\r\n            \"0xFD\" : {SIZE: 4, TYPE: \"U32\", NAME : \"dataloggerTimestamp\"},\r\n            \"0x12\" : {SIZE: 1, NAME: \"adr\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",}},\r\n            \"0x13\" : {SIZE: 1, NAME: \"sf\", SIZE: 1, VALUES: {\r\n                    \"0x00\" : \"SF12BW125\",\r\n                    \"0x01\" : \"SF11BW125\",\r\n                    \"0x02\" : \"SF10BW125\",\r\n                    \"0x03\" : \"SF9BW125\",\r\n                    \"0x04\" : \"SF8BW125\",\r\n                    \"0x05\" : \"SF7BW125\",\r\n                    \"0x06\" : \"SF7BW250\",\r\n                }\r\n            },\r\n            \"0x14\" : {SIZE: 1, NAME : \"lorawanWatchdogFunction\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",},},\r\n            \"0x15\" : {SIZE: 2, NAME : \"lorawanWatchdogTimeout\",},\r\n            \"0x16\" : {SIZE: 1, NAME : \"lorawanWatchdogAlarm\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"alarm\",},},\r\n            \"0x64\" : {SIZE: 1, NAME : \"defaultState\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME, \"0x02\":RELAY.RETAIN_NAME}},\r\n            \"0x65\" : {SIZE: 1, NAME : \"timeoutState\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME, \"0x02\":RELAY.RETAIN_NAME}},\r\n            \"0x66\" : {SIZE: 1, NAME : \"buttonOverrideFunction\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",}},\r\n            \"0x67\" : {SIZE: 1, NAME : \"deviceOperationMode\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"override\",}},\r\n            \"0x69\" : {SIZE: 1, NAME : \"internalCircuitTemperatureAlarm\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"alarm\",}},\r\n            \"0x70\" : {SIZE: 4, NAME : \"internalCircuitTemperatureNumberOfAlarms\",},\r\n            \"0x71\" : {SIZE: 2, NAME : \"internalCircuitTemperature\", RESOLUTION: 0.01, SIGNED: true},\r\n            \"0x72\" : {SIZE: 1, NAME : \"internalCircuitHumidity\",},\r\n            \"0x95\" : {SIZE: 1, NAME : RELAY.CHANNEL_1_STATE_NAME, VALUES: CHANNEL_STATES},\r\n            \"0x96\" : {SIZE: 1, NAME : \"channel1Control\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME,}},\r\n            \"0x97\" : {SIZE: 4, NAME : \"channel1Counter\",},\r\n            \"0x98\" : {SIZE: 1, NAME : RELAY.CHANNEL_2_STATE_NAME, VALUES: CHANNEL_STATES},\r\n            \"0x99\" : {SIZE: 1, NAME : \"channel2Control\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME,}},\r\n            \"0x9A\" : {SIZE: 4, NAME : \"channel2Counter\",},\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_PERIODIC.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_PERIODIC.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // Type of device data\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        // No channel checking\r\n        var info = CONFIG_PERIODIC.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded[CONFIG_PERIODIC.ERROR_NAME] = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        // Decoding\r\n        var value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n        if(info.SIGNED != null)\r\n        {\r\n            value = parseBytesToAnyInt(bytes, index, size, true);\r\n        }\r\n        if(info.VALUES != null)\r\n        {\r\n            value = \"0x\" + byteToEvenHex(value).toUpperCase();\r\n            value = info.VALUES[value];\r\n        }\r\n        if(info.RESOLUTION != null)\r\n        {\r\n            value = value * info.RESOLUTION;\r\n            value = toFixed(value, 2);\r\n        }\r\n        decoded[info.NAME] = value;\r\n        index = index + size;\r\n    }\r\n    return decoded;\r\n}\r\n\r\nfunction decodeAlarmPacket(bytes)\r\n{\r\n    // Configuration constants for alarm packet\r\n    var CONFIG_ALARM = {\r\n        FPORT : 11,\r\n        CHANNEL : 0xAA,\r\n        TYPES : {\r\n            \"0xFE\" : {SIZE: 4, NAME : \"timestamp\"},\r\n            \"0x00\" : {SIZE: 1, NAME : \"internalTemperatureAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"normal\",\r\n                    \"0x01\" : \"alarm\",\r\n                },\r\n            },\r\n            \"0x01\" : {SIZE: 1, NAME : RELAY.CHANNEL_1_STATE_NAME,\r\n                VALUES     : CHANNEL_STATES,\r\n            },\r\n            \"0x02\" : {SIZE: 1, NAME : RELAY.CHANNEL_2_STATE_NAME,\r\n                VALUES     : CHANNEL_STATES,\r\n            },\r\n            \"0x03\" : {SIZE: 1, NAME : \"lorawanWatchdogAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"normal\",\r\n                    \"0x01\" : \"alarm\",\r\n                },\r\n            },\r\n            \"0x97\" : {SIZE: 4, NAME : \"channel1Counter\",},\r\n            \"0x9A\" : {SIZE: 4, NAME : \"channel2Counter\",},\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_ALARM.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_ALARM.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // Channel checking\r\n        if(channel != CONFIG_ALARM.CHANNEL)\r\n        {\r\n            decoded[CONFIG_ALARM.ERROR_NAME] = \"can't decode channel \"+ channel;\r\n            return decoded;\r\n        }\r\n        // Type of alarm\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        var info = CONFIG_ALARM.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded[CONFIG_ALARM.ERROR_NAME] = \"can't decode type \"+ channel;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        if(size == null)\r\n        {\r\n            decoded[CONFIG_ALARM.ERROR_NAME] = \"type \" + type + \" doesn't have any data\";\r\n            return decoded;\r\n        }\r\n        // Decoding\r\n        var value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n        if(info.VALUES != null)\r\n        {\r\n            value = \"0x\" + byteToEvenHex(value).toUpperCase();\r\n            value = info.VALUES[value];\r\n        }\r\n        decoded[info.NAME] = value;\r\n        index = index + size;\r\n    }\r\n    return decoded;\r\n}\r\n\r\nfunction decodeParameters(bytes)\r\n{\r\n    // Configuration constants for parameters reading\r\n    var CONFIG_PARAMETER = {\r\n        FPORT : 100,\r\n        CHANNEL : 0xFF,\r\n        TYPES : {\r\n            \"0x12\" : {SIZE: 1, NAME: \"adr\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",}},\r\n            \"0x13\" : {SIZE: 1, NAME: \"sf\", SIZE: 1, VALUES: {\r\n                    \"0x00\" : \"SF12BW125\",\r\n                    \"0x01\" : \"SF11BW125\",\r\n                    \"0x02\" : \"SF10BW125\",\r\n                    \"0x03\" : \"SF9BW125\",\r\n                    \"0x04\" : \"SF8BW125\",\r\n                    \"0x05\" : \"SF7BW125\",\r\n                    \"0x06\" : \"SF7BW250\",\r\n                }\r\n            },\r\n            \"0x14\" : {SIZE: 1, NAME : \"lorawanWatchdogFunction\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",},},\r\n            \"0x15\" : {SIZE: 2, NAME : \"lorawanWatchdogTimeout\",},\r\n            \"0x16\" : {SIZE: 1, NAME : \"lorawanWatchdogAlarm\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"alarm\",},},\r\n            \"0x64\" : {SIZE: 1, NAME : \"defaultState\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME, \"0x02\":RELAY.RETAIN_NAME}},\r\n            \"0x65\" : {SIZE: 1, NAME : \"timeoutState\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME, \"0x02\":RELAY.RETAIN_NAME}},\r\n            \"0x66\" : {SIZE: 1, NAME : \"buttonOverrideFunction\", VALUES: {\"0x00\" : \"disabled\", \"0x01\" : \"enabled\",}},\r\n            \"0x67\" : {SIZE: 1, NAME : \"deviceOperationMode\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"override\",}},\r\n            \"0x69\" : {SIZE: 1, NAME : \"internalCircuitTemperatureAlarm\", VALUES: {\"0x00\" : \"normal\", \"0x01\" : \"alarm\",}},\r\n            \"0x70\" : {SIZE: 4, NAME : \"internalCircuitTemperatureNumberOfAlarms\",},\r\n            \"0x71\" : {SIZE: 2, NAME : \"internalCircuitTemperature\", RESOLUTION: 0.01, SIGNED: true},\r\n            \"0x72\" : {SIZE: 1, NAME : \"internalCircuitHumidity\",},\r\n            \"0x95\" : {SIZE: 1, NAME : RELAY.CHANNEL_1_STATE_NAME, VALUES: CHANNEL_STATES},\r\n            \"0x96\" : {SIZE: 1, NAME : \"channel1Control\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME,}},\r\n            \"0x97\" : {SIZE: 4, NAME : \"channel1Counter\",},\r\n            \"0x98\" : {SIZE: 1, NAME : RELAY.CHANNEL_2_STATE_NAME, VALUES: CHANNEL_STATES},\r\n            \"0x99\" : {SIZE: 1, NAME : \"channel2Control\", VALUES: {\"0x00\":RELAY.OFF_NAME, \"0x01\":RELAY.ON_NAME,}},\r\n            \"0x9A\" : {SIZE: 4, NAME : \"channel2Counter\",},\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_PARAMETER.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_PARAMETER.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // Channel checking\r\n        if(channel != CONFIG_PARAMETER.CHANNEL)\r\n        {\r\n            decoded[CONFIG_PARAMETER.ERROR_NAME] = \"can't decode channel \"+ channel;\r\n            return decoded;\r\n        }\r\n        // Type of parameter\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        var info = CONFIG_PARAMETER.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded[CONFIG_PARAMETER.ERROR_NAME] = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        if(size == null)\r\n        {\r\n            decoded[CONFIG_ALARM.ERROR_NAME] = \"type \" + type + \" doesn't have any data\";\r\n            return decoded;\r\n        }\r\n        // Decoding\r\n        var value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n        if(info.SIGNED != null)\r\n        {\r\n            value = getSignedIntegerFromInteger(value, size);\r\n        }\r\n        if(info.VALUES != null)\r\n        {\r\n            value = \"0x\" + byteToEvenHex(value).toUpperCase();\r\n            value = info.VALUES[value];\r\n        }\r\n        if(info.RESOLUTION != null)\r\n        {\r\n            value = value * info.RESOLUTION;\r\n            value = toFixed(value, 2);\r\n        }\r\n        decoded[info.NAME] = value;\r\n        index = index + size;\r\n    }\r\n    return decoded;\r\n}\r\n\r\nfunction getSizeBasedOnChannel(bytes, index, channel)\r\n{\r\n    var size = 0;\r\n    while(index + size < bytes.length && bytes[index + size] != channel)\r\n    {\r\n        size = size + 1;\r\n    }\r\n    return size;\r\n}\r\n\r\nfunction getStringFromBytesBigEndianFormat(bytes, index, size)\r\n{\r\n    var byteArray = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        byteArray.push(bytes[index+i]);\r\n    }\r\n    return bytesToString(byteArray);\r\n}\r\n\r\nfunction getStringFromBytesLittleEndianFormat(bytes, index, size)\r\n{\r\n    var byteArray = [];\r\n    for(var i=(size - 1); i>=0; i=i-1)\r\n    {\r\n        byteArray.push(bytes[index+i]);\r\n    }\r\n    return bytesToString(byteArray);\r\n}\r\n\r\nfunction getValueFromBytesBigEndianFormat(bytes, index, size)\r\n{\r\n    if(size >= 4){\r\n        return parseBytesToLong(bytes, index, size, true);\r\n    }\r\n    return parseBytesToInt(bytes, index, size, true);\r\n}\r\n\r\nfunction getValueFromBytesLittleEndianFormat(bytes, index, size)\r\n{\r\n    if(size >= 4){\r\n        return parseBytesToLong(bytes, index, size, false);\r\n    }\r\n    return parseBytesToInt(bytes, index, size, false);\r\n}\r\n\r\nfunction getDigitStringArrayNoFormat(bytes, index, size)\r\n{\r\n    var hexString = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        hexString.push(Integer.toString(bytes[index+i], 16));\r\n    }\r\n    return hexString;\r\n}\r\n\r\nfunction getDigitStringArrayEvenFormat(bytes, index, size)\r\n{\r\n    var hexString = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        hexString.push(byteToEvenHex(bytes[index+i]));\r\n    }\r\n    return hexString;\r\n}\r\n\r\nfunction toEvenHEX(hex)\r\n{\r\n    if(hex.length == 1)\r\n    {\r\n        return \"0\"+hex;\r\n    }\r\n    return hex;\r\n}\r\n\r\n\r\nfunction byteToEvenHex(val)\r\n{\r\n    return toEvenHEX(Integer.toString(val, 16));\r\n}\r\n\r\nfunction hexStringToIntList(hexString)\r\n{\r\n    var bytes = [];\r\n    var hexByte = \"\";\r\n    for(var i=0; i<hexString.length; i=i+2)\r\n    {\r\n        hexByte = hexString[i] + hexString[i+1];\r\n        bytes.push(parseHexToInt(hexByte));\r\n    }\r\n    return bytes;\r\n}\r\n\r\n/**\r\n * @brief This function supports conversion to positive or negative value of type INT8, INT16, INT24, INT32, etc.. \r\n */\r\nfunction parseBytesToAnyInt(bytes, offset, length, bigEndian)\r\n{\r\n    var byteArray = [];\r\n    if(length > 4)\r\n    {\r\n        return parseBytesToLong(bytes, offset, length, bigEndian);\r\n    }\r\n    var value = parseBytesToInt(bytes, offset, length, bigEndian);\r\n    var isValueNegative = false;\r\n    var CONFIG_TYPE = {\r\n        INT8_MAX : 127,\r\n        INT16_MAX : 32767,\r\n        INT24_MAX : 8388607,\r\n    };\r\n    \r\n    if(length == 1){\r\n        if(value > CONFIG_TYPE.INT8_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }else if(length == 2){\r\n        if(value > CONFIG_TYPE.INT16_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }else if(length == 3){\r\n        if(value > CONFIG_TYPE.INT24_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }\r\n\r\n    if(isValueNegative == false)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    for(var i=0; i<4; i=i+1){\r\n        if(i < (4 - length)){\r\n            byteArray.push(255);\r\n        }else{\r\n            var index = i - (4 - length);\r\n            if(bigEndian){\r\n                byteArray.push(bytes[offset + index]);\r\n            }else{\r\n                byteArray.push(bytes[offset + (length - 1) - index]);\r\n            }\r\n        }\r\n    }\r\n    return parseBytesToInt(byteArray, 0, 4, bigEndian);\r\n}\r\n\r\n/************************************************************************************************************/\r\n\r\n// Decode decodes an array of bytes into an object. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - bytes is an array of bytes, e.g. [225, 230, 255, 0]\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an object, e.g. {\"temperature\": 22.5}\r\nfunction Decode(fPort, bytes, variables) \r\n{\r\n    var decoded = {};\r\n    if(fPort == 0)\r\n    {\r\n        decoded = {mac: \"MAC command received\", fPort: fPort};\r\n    }else if(fPort == 50)\r\n    {\r\n        decoded = decodeBasicInformation(bytes);\r\n    }else if(fPort >= 1 && fPort <= 5)\r\n    {\r\n        decoded = decodeDeviceData(bytes);\r\n    }else if(fPort == 11)\r\n    {\r\n        decoded = decodeAlarmPacket(bytes);\r\n    }else if(fPort == 100)\r\n    {\r\n        decoded = decodeParameters(bytes);\r\n    }else\r\n    {\r\n        decoded = {error: \"Incorrect fPort\", fPort : fPort};\r\n    }\r\n    return decoded;\r\n}\r\n\r\n// Decode uplink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - bytes = Byte array containing the uplink payload, e.g. [255, 230, 255, 0]\r\n// - fPort = Uplink fPort.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - data = Object representing the decoded payload.\r\nfunction decodeUplink(input) {\r\n    return {\r\n        data: Decode(input.fPort, input.bytes, input.variables)\r\n    };\r\n}\r\n\r\nfunction getVersionControl()\r\n{\r\n    // Version Control\r\n    var VERSION_CONTROL = {\r\n        CODEC : {VERSION: \"1.0.0\", NAME: \"codecVersion\"},\r\n        DEVICE: {MODEL : \"RM200\", NAME: \"genericModel\"},\r\n        PRODUCT: {CODE : \"P1002003\", NAME: \"productCode\"},\r\n        MANUFACTURER: {COMPANY : \"YOBIIQ B.V.\", NAME: \"manufacturer\"},\r\n    };\r\n    var decoded = {};\r\n    decoded[VERSION_CONTROL.CODEC.NAME] = VERSION_CONTROL.CODEC.VERSION;\r\n    decoded[VERSION_CONTROL.DEVICE.NAME] = VERSION_CONTROL.DEVICE.MODEL;\r\n    decoded[VERSION_CONTROL.PRODUCT.NAME] = VERSION_CONTROL.PRODUCT.CODE;\r\n    decoded[VERSION_CONTROL.MANUFACTURER.NAME] = VERSION_CONTROL.MANUFACTURER.COMPANY;\r\n    return decoded;\r\n}",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "manufacturer"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}