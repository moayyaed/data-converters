{
  "name": "ChirpStack Downlink data converter for Yobiiq RM200",
  "type": "DOWNLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions 'decodeToString' and 'decodeToJson' are already built-in **/\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": "// Process data from incoming message and metadata\r\nvar input = {\r\n    fPort : parseInt(metadata.rc_fPort), // from rule chain\r\n    confirmed : metadata.rc_confirmed === \"true\" ? true : false, // from rule chain\r\n    data : msg,\r\n    variables: null,\r\n    devEui : metadata.cs_devEui, // from client scope\r\n    applicationId: metadata.cs_applicationId, // from client scope\r\n};\r\n\r\n// Constants for device configuration \r\nvar CONFIG_DEVICE = {\r\n    FPORT : 50,\r\n    REGISTER_CHANNEL : 0xFF,\r\n    PERIODIC_CHANNEL : 0xFF,\r\n    PERIODIC_INTERVAL_TYPE : 0x14,\r\n    PERIODIC_MODE_TYPE : 0x15,\r\n    PERIODIC_STATUS_TYPE : 0x16,\r\n    PERIODIC_REGISTERS_TYPE : 0x17,\r\n    READING_TYPE : 0xCC,\r\n    DATA_MAX_SIZE : 10,\r\n    REGISTERS : {\r\n        \"rebootDevice\": {TYPE: 0x0A, SIZE: 1, MIN: 1, MAX: 1, RIGHT:\"WRITE_ONLY\",},\r\n        \"restart\": {TYPE: 0x0B, SIZE: 1, MIN: 1, MAX: 1, RIGHT:\"WRITE_ONLY\",},\r\n        \"adr\": {TYPE: 0x12, SIZE: 1, MIN: 0, MAX: 1,},\r\n        \"sf\": {TYPE: 0x13, SIZE: 1, MIN: 0, MAX: 6,},\r\n        \"lorawanWatchdogFunction\": {TYPE: 0x14, SIZE: 1, MIN: 0, MAX: 1,},\r\n        \"lorawanWatchdogTimeout\": {TYPE : 0x15, SIZE: 2, MIN: 1, MAX: 65535,},\r\n        \"lorawanWatchdogAlarm\": {TYPE: 0x16, RIGHT:\"READ_ONLY\"},\r\n        \"defaultState\": {TYPE: 0x64, SIZE: 1, MIN: 0, MAX: 2,},\r\n        \"timeoutState\": {TYPE: 0x65, SIZE: 1, MIN: 0, MAX: 2,},\r\n        \"buttonOverrideFunction\": {TYPE: 0x66, SIZE: 1, MIN: 0, MAX: 1,},\r\n        \"deviceOperationMode\": {TYPE: 0x67, RIGHT:\"READ_ONLY\"},\r\n        \"buttonOverrideReset\": {TYPE: 0x68, SIZE: 1, MIN: 1, MAX: 1, RIGHT:\"WRITE_ONLY\",},\r\n        \"internalCircuitTemperatureAlarm\": {TYPE: 0x69, RIGHT:\"READ_ONLY\"},\r\n        \"internalCircuitTemperatureNumberOfAlarms\": {TYPE: 0x70, RIGHT:\"READ_ONLY\"},\r\n        \"internalCircuitTemperature\": {TYPE: 0x71, RIGHT:\"READ_ONLY\"},\r\n        \"internalCircuitHumidity\": {TYPE: 0x72, RIGHT:\"READ_ONLY\"},\r\n        \"channel1State\": {TYPE: 0x95, RIGHT:\"READ_ONLY\",},\r\n        \"channel1Control\": {TYPE: 0x96, SIZE: 1, MIN: 0, MAX: 1,},\r\n        \"channel1Counter\": {TYPE: 0x97, RIGHT:\"READ_ONLY\",},\r\n        \"channel2State\": {TYPE: 0x98, RIGHT:\"READ_ONLY\",},\r\n        \"channel2Control\": {TYPE: 0x99, SIZE: 1, MIN: 0, MAX: 1,},\r\n        \"channel2Counter\": {TYPE: 0x9A, RIGHT:\"READ_ONLY\",},\r\n    }\r\n};\r\n\r\n// Result object with encoded downlink payload\r\nvar result = {\r\n\r\n    // downlink data content type: JSON, TEXT or BINARY (base64 format)\r\n    contentType: \"TEXT\",\r\n\r\n    // downlink data\r\n    data: bytesToBase64(encodeDownlink(input).bytes),\r\n\r\n    // Optional metadata object presented in key/value format\r\n    metadata: {\r\n        eui: input.devEui,\r\n        DevEUI: input.devEui,\r\n        fPort: input.fPort,\r\n    }\r\n\r\n};\r\n\r\n\r\nreturn result;\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Encode downlink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - data = Object representing the payload that must be encoded.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - bytes = Byte array containing the downlink payload.\r\nfunction encodeDownlink(input) {\r\n    return {\r\n        bytes: Encode(null, input.data, input.variables)\r\n    };\r\n}\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Encode encodes the given object into an array of bytes. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - obj is an object, e.g. {\"temperature\": 22.5}\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\r\nfunction Encode(fPort, obj, variables) {\r\n    // Constants for downlink type\r\n    var CONFIG_DOWNLINK = {\r\n        TYPE    : \"Type\",\r\n        CONFIG  : \"Config\",\r\n        PERIODIC: \"Periodic\",\r\n        READING : \"Reading\"\r\n    };\r\n\r\n    if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.CONFIG)\r\n    {\r\n        return encodeDeviceConfiguration(obj[CONFIG_DOWNLINK.CONFIG]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.PERIODIC)\r\n    {\r\n        return encodeUplinkConfiguration(obj[CONFIG_DOWNLINK.PERIODIC]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.READING)\r\n    {\r\n        return encodeParamtersReading(obj[CONFIG_DOWNLINK.READING]);\r\n    }\r\n\r\n    return [];\r\n}\r\n\r\n// Encode downlink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - data = Object representing the payload that must be encoded.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - bytes = Byte array containing the downlink payload.\r\nfunction encodeDownlink(input) {\r\n    return {\r\n        bytes: Encode(null, input.data, input.variables)\r\n    };\r\n}\r\n\r\n/************************************************************************************************************/\r\n\r\n\r\nfunction encodeDeviceConfiguration(configs)\r\n{\r\n    var encoded = [];\r\n\r\n    foreach(configObj : configs)\r\n    {\r\n        var param = configObj.Param;\r\n        var value = configObj.Value;\r\n        if(value == null || param == null){\r\n            return []; // error\r\n        }\r\n\r\n        var config = CONFIG_DEVICE.REGISTERS[param];\r\n        if(config == null) {\r\n            return []; // error\r\n        }\r\n        if(config.RIGHT != null && config.RIGHT == \"READ_ONLY\")\r\n        {\r\n            return []; // error\r\n        } \r\n        if(value < config.MIN || value > config.MAX) {\r\n            return []; // error\r\n        }\r\n        \r\n        encoded.push(CONFIG_DEVICE.REGISTER_CHANNEL);\r\n        encoded.push(config.TYPE);\r\n        if(config.SIZE == 1)\r\n        {\r\n            encoded.push(value);\r\n        }else if(config.SIZE == 2)\r\n        {\r\n            encoded.push( (value >> 8) % 256 );\r\n            encoded.push( value % 256 );\r\n        }else{\r\n            return []; // error\r\n        }\r\n    }\r\n\r\n    return encoded;\r\n}\r\n\r\nfunction encodeUplinkConfiguration(configObj)\r\n{\r\n    var encoded = [];\r\n    var config = {};\r\n\r\n    if(configObj.UplinkInterval == null || configObj.Mode == null ||\r\n        configObj.Status == null || configObj.Registers == null){\r\n        return []; // error\r\n    }\r\n    \r\n    // Encode UplinkInterval, Mode, Status\r\n    if(configObj.UplinkInterval < 0 || configObj.UplinkInterval > 255){\r\n        return []; // error\r\n    }\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_CHANNEL);\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_INTERVAL_TYPE);\r\n    encoded.push(configObj.UplinkInterval);\r\n\r\n    if(configObj.Mode < 0 || configObj.Mode > 1){\r\n        return []; // error\r\n    }\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_CHANNEL);\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_MODE_TYPE);\r\n    encoded.push(configObj.Mode);\r\n    \r\n    if(configObj.Status < 0 || configObj.Status > 1){\r\n        return []; // error\r\n    }\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_CHANNEL);\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_STATUS_TYPE);\r\n    encoded.push(configObj.Status);\r\n\r\n    // Encode Registers\r\n    if(configObj.Registers.size < 0 || \r\n        configObj.Registers.size > CONFIG_DEVICE.DATA_MAX_SIZE){\r\n        return []; // error\r\n    }\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_CHANNEL);\r\n    encoded.push(CONFIG_DEVICE.PERIODIC_REGISTERS_TYPE);\r\n    foreach(field : configObj.Registers)\r\n    {\r\n        config = CONFIG_DEVICE.REGISTERS[field];\r\n        if(config == null){\r\n            return []; // error\r\n        }\r\n        encoded.push(config.TYPE);\r\n    }\r\n\r\n    return encoded;\r\n}\r\n\r\nfunction encodeParamtersReading(configObj)\r\n{\r\n    var encoded = [];\r\n    var config = {};\r\n\r\n    if(configObj.length > CONFIG_DEVICE.DATA_MAX_SIZE)\r\n    {\r\n        return []; // error\r\n    }\r\n    encoded.push(CONFIG_DEVICE.REGISTER_CHANNEL);\r\n    encoded.push(CONFIG_DEVICE.READING_TYPE);\r\n    foreach(param : configObj)\r\n    {\r\n        config = CONFIG_DEVICE.REGISTERS[param];\r\n        if(config == null)\r\n        {\r\n            return []; // error\r\n        }\r\n        if(config.RIGHT != null && config.RIGHT == \"WRITE_ONLY\")\r\n        {\r\n            return [];  // error\r\n        }\r\n        encoded.push(config.TYPE);\r\n    }\r\n\r\n    return encoded;\r\n}",
    "updateOnlyKeys": [
      "manufacturer"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}