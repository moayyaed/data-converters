{
    "name": "The Things Stack Community Uplink data converter for Yobiiq SD-1001",
    "type": "UPLINK",
    "debugMode": true,
    "configuration": {
      "scriptLang": "TBEL",
      "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
      "tbelDecoder": "var data = decodeToJson(payload);\r\n\r\nvar deviceName = data.end_device_ids.device_id;\r\nvar deviceType = 'Smoke Detector';\r\nvar groupName = 'Smoke Detectors';\r\n\r\n// --- attributes and telemetry objects ---\r\nvar telemetry = {};\r\nvar attributes = {};\r\n// --- attributes and telemetry objects ---\r\n\r\n// --- Timestamp parsing\r\nvar dateString = data.uplink_message.received_at;\r\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\r\nif ((data.simulated != null && data.simulated) || dateString == null) {\r\n  dateString = data.received_at;\r\n}\r\nvar timestamp = -1;\r\nif (dateString != null) {\r\n  timestamp = new Date(dateString).getTime();\r\n  if (timestamp == -1) {\r\n    var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\r\n    var millisecondsEndIndex = dateString.lastIndexOf('+');\r\n    if (millisecondsEndIndex == -1) {\r\n      millisecondsEndIndex = dateString.lastIndexOf('Z');\r\n    }\r\n    if (millisecondsEndIndex == -1) {\r\n      millisecondsEndIndex = dateString.lastIndexOf('-');\r\n    }\r\n    if (millisecondsEndIndex == -1) {\r\n      if (dateString.length >= secondsSeparatorIndex + 3) {\r\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3);\r\n      }\r\n    } else {\r\n      dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\r\n          dateString.substring(millisecondsEndIndex, dateString.length);\r\n    }\r\n    timestamp = new Date(dateString).getTime();\r\n  }\r\n}\r\n// If we cannot parse timestamp - we will use the current timestamp\r\nif (timestamp == -1) {\r\n  timestamp = Date.now();\r\n}\r\n\r\n// You can add some keys manually to attributes or telemetry\r\nattributes.devEui = data.end_device_ids.dev_eui;\r\nattributes.devId = data.end_device_ids.device_id;\r\nattributes.applicationId = data.end_device_ids.application_ids.application_id;\r\nattributes.fPort = data.uplink_message.f_port;\r\n// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually\r\nattributes.correlation_ids = data.correlation_ids;\r\n\r\n// You can exclude some keys from the result\r\nvar excludeFromTelemetryList = [\"uplink_token\", \"gateway_id\", \"settings\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"network_ids\",\"session_key_id\",\"eui\"];\r\nvar excludeFromAttributesList = [\"uplink_token\", \"gateway_id\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"session_key_id\", \"dev_eui\",\"channel_index\",\"channel_rssi\",\"consumed_airtime\",\"frequency_offset\",\"session_key_id\",\"faultAlarm\",\"smokeAlarm\",\"faultAlarm\",\"interconnectAlarm\",\"lowBatteryAlarm\",\"batteryLevelInPercentage\",\"powerEvent\",\"rssi\",\"snr\",\"confirmed\",\"frm_payload\",\"f_cnt\"];\r\n\r\n// Message parsing\r\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\r\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.\r\nvar telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);\r\nvar attributesData = {};\r\nattributesData.putAll(toFlatMap(data.uplink_message.settings, excludeFromAttributesList, false));\r\nattributesData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromAttributesList, false));\r\nattributesData.putAll(toFlatMap(data.uplink_message, excludeFromAttributesList, false));\r\n\r\ntelemetry.putAll(telemetryData);\r\nattributes.putAll(attributesData);\r\n\r\nvar result = {\r\n  deviceName: deviceName,\r\n  deviceType: deviceType,\r\n  groupName: groupName,\r\n  attributes: attributes,\r\n  telemetry: {\r\n    ts: timestamp,\r\n    values: telemetry\r\n  }\r\n};\r\n\r\nreturn result;",
      "encoder": null,
      "tbelEncoder": null,
      "updateOnlyKeys": [
        "manufacturer"
      ]
    },
    "additionalInfo": {
      "description": ""
    },
    "edgeTemplate": false
  }